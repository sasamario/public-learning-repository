# 午後問題　データベース

午後のデータベース分野では以下出題範囲。  
・データモデル  
★ 正規化  
・DBMS  
★ データベース言語(SQL)  
・データベースシステムの運用、保守

■ 解いてみた所感  
・比較的解ける。きちんと問題も読むこと  
・ER 図のエンティティ、リレーションの穴埋め問題がよく出る  
・SQL の穴埋め問題もよく出る  
・SQL の穴埋めはきちんとスペル間違いしないよう回答できるようにしておく（雰囲気で覚えないこと）

■ 注意点  
・ER 図のエンティティの穴埋めの際に、主キーや外部キーの場合線や波線をつけて回答することを忘れずに！！！

# データベースの設計

2025 年 午後問題重点対策 p297〜

データベース設計では、テーブル設計が主な内容。  
業務要件に従って、各テーブルに必要な属性やキーを解答するといった問題、エンティティ間の多重度（カーディナリティ）に着目した問題など。

## テーブル設計

■ キーワード  
・参照整合性  
・参照制約  
・外部キー

リレーショナルデータベースの DBMS では、参照整合性を保つための機能として、外部キーや参照制約がある。  
外部キーの値は、参照先テーブルの特定の 1 行を指すものである必要がある。こうした項目は通常主キーとなるので、外部キーは参照先テーブルの主キーと同じ値を持つ項目と考えて良いとのこと（厳密には違うが）

なお、参照整合性を維持するためには以下のルールを守る必要がある。  
・外部テーブルに存在しない値を、主テーブル（外部テーブルではないほう）に追加してはいけない　※参照先にデータがないため
・主テーブルで外部キーとして使用している値を、外部テーブル側で削除してはいけない　※その値を参照しているため

■ 参考過去問  
・[参照制約 H28 春 29, H22 秋 32](https://www.ap-siken.com/kakomon/28_haru/q29.html)

## ★ 多重度（カーディナリティ）

関連の多重度とは、テーブルやエンティティ間の数的な対応関係のこと。  
多重度には、「1 対 1」「1 対多（多 対 1）」「多 対 多」の 3 つがある。

### ■ ポイント

・主テーブルと外部テーブルの多重度（カーディナリティ）  
原則として、主キーを持つエンティティと、その主キーを外部キーとしてもつエンティティのカーディナリティは「1 対 多」となる。  
→ 外部キーは、外部テーブル側では主キーである。そのため、一意にレコードが確定する。一方主テーブル側では同じ外部キーを持つレコードは複数存在しうるので多となる。そのため、「1 対 多」となる。

・多対多の関係について
「多 対 多」の関係は、関係データベースにそのまま持ち込むことはできない。この場合、多対多の関係を紐づける、中間テーブルを使い「1 対 多」の関係に分解する必要がある。

参考：[やさしい図解で学ぶ　中間テーブル　多対多　概念編](https://qiita.com/ramuneru/items/db43589551dd0c00fef9)

## ★ 正規化

正規化とは、データの重複をなくし、データの更新に適したテーブルとなるように整理する作業。  
問題で出る時は順番に正規化をしてみるとイメージがつきやすいかも。重点対策の p303 にある「H12 春」の問題が練習に良い。

正規化には以下の 4 つがある。  
■ 非正規形  
非正規形は、テーブル内に繰り返し部分を持った状態。レコードごと項目数が異なる。  
この状態では管理できないので正規化を行う必要がある。

■ 第 1 正規形  
第 1 正規形は、非正規形から繰り返し部分を取り除いた状態。

■ 第 2 正規形  
第 2 正規形は、第 1 正規形二の表に対して、「主キーの一部の項目だけに従属する項目（部分的関数従属）」を含まなくなるように整理したもの。  
要は、複合キーの 1 部項目だけでレコードの値が一意に定まるということ。そのため、必然的に第 1 正規形で複合キーを持たない場合は、第二正規化済みということになる。

■ 第 3 正規形  
第 3 正規形は、第 2 正規形の表に対して、主キー以外の項目に従属するような項目がなくなるように整理したもの。

■ 参考過去問  
・[正規形と特徴の組み合わせ R4 春 28, H30 秋 28, H24 春 27](https://www.ap-siken.com/kakomon/04_haru/q28.html)  
・[どのレベルまでの正規形か H29 春 27, H22 春 32](https://www.ap-siken.com/kakomon/29_haru/q27.html)  
・[どこまで正規化されたものか H26 春 27](https://www.ap-siken.com/kakomon/26_haru/q27.html)  
・[第 3 正規形に変換する手順はどれか H25 秋 29](https://www.ap-siken.com/kakomon/25_aki/q29.html)

# DBMS の制御

## ロールバックとロールフォワード

システムで障害が発生した場合、システム障害発生時までにコミットされているトランザクションは復元（ロールフォワード）、コミットされていないトランザクションは取り消す（ロールバック）する。

DBMS では、性能向上のためデータベースをすぐに更新せず、更新内容をバッファと呼ばれるメモリ上の領域に記録する（その方が速度的に速いので）。  
★ そして、「チェックポイント」と呼ばれる一定の周期ごとに、その内容を一括してデータベースに反映する。

■ 参考過去問  
・[DBMS のチェックポイント R6 秋 31](https://www.ap-siken.com/kakomon/06_aki/q31.html)  
・[DBMS の障害回復 R5 秋 30, H28 秋 30](https://www.ap-siken.com/kakomon/05_aki/q30.html)  
・[前進復帰可能なトランザクション R4 秋 29, H27 秋 30](https://www.ap-siken.com/kakomon/04_aki/q29.html)

# 分散データベース

TODO... p322

# 文

## 相関問合せ

相関問合せでは、主問合せと副問合せが関連しながら実行される。

```sql
SELECT 氏名
  FROM 学生テーブル
  WHERE EXISTS (SELECT *
    FROM 出身校テーブル
    WHERE 出身校テーブル.学校コード = 学生テーブル.出身コード
      AND 地域名 = '関東')
```

上記例だと、主問合せによって取り出される「各行」に対して、1 行ずつ別に副問合せ側で指定された条件検索が行われる。
そのためこの場合だと、学生テーブルの行に対して出身校テーブルにある出身コードで、かつ地域名が「関東」のレコードが存在するレコードを取得している。

デメリットとして、主問合せの各行に対して副問合せが評価されるためデータ数が多いとパフォーマンスに影響が出る。

## CREATE TABLE

CREATE TABLE は名前の通り、テーブルを作成する文。  
基本的な構文でよく出るので押さえておこう（穴埋め形式に対応できるよう、それぞれ記述できるようにしておくこと）  
→PRIMARY KEY, FOREIGN KEY とか

■ 構文

```sql
CREATE TABLE [テーブル名]
(
[列名1] [データ型] [この列の制約],
[列名2] [データ型] [この列の制約],
[このテーブルの制約1],[このテーブルの制約2], ...);
```

[制約]：DEFAULT, NOT NULL, PRIMARY KEY, FOREIGN KEY, UNIQUE 等

例）departmetns（部署）, employees（従業員） テーブルの作成

```sql
CREATE TABLE departments (
  id INT PRIMARY KEY,
  name VARCHAR(100) NOT NULL
);

CREATE TABLE employees (
  id INT PRIMARY KEY,
  name VARCHAR(100) NOT NULL DEFAULT 'Unknown',
  age INT NOT NULL DEFAULT 30,
  department_id INT,
  FOREIGN KEY (department_id) REFERENCES departments(id)
);
```

外部キー制約をつける場合は、以下のように記述する。

```sql
FOREIGN KEY [カラム名] REFERENCES [参照先テーブル(参照先カラム名)]
```

## GRANT

GRANT 文は、特定のユーザにアクセス権やロールを付与する。  
出題：R4 秋

■ 構文

```sql
GRANT [権限リスト] ON [データベースオブジェクト] TO [ユーザー];
```

- [権限リスト]：SELECT, UPDATE, INSERT, DELETE, ALL PRIVILEGES（全てという意味）の中から 1 つ以上
- [データベースオブジェクト]：データベース名やテーブル名
- [ユーザー]：権限を付与する対象のユーザー名

例）test_user に User テーブルの SELECT 権限を付与する場合  
`GRANT SELECT ON User TO test_user`

ちなみに以下のように指定すると特定のカラムに対してのみ参照権限を付与することもできる。  
`GRANT SELECT(id, name) ON User TO test_user`

# 句

## HAVING 句

HAVING 句は、GROUP BY 句でグループ化されたデータに対して条件を指定するために使用される句.  
HAVING 句にかける要素は「定数」「集約関数」「GROUP BY 句で指定した列名（つまり集約キー）」の 3 つ。  
※ただし、集約キーに対する条件指定については WHERE 句でもできるのでそちらで指定した方が良い（わかりいやすさ、パフォーマンスの観点から）。

### WEHERE 句と HAVING 句の違い

- WHERE 句：グループ化前にデータをフィルタリングする。つまり、集計が行われる前に条件を適用する。
- HAVING 句：グループ化後に「集計結果」に対して条件を適用する。集計関数（SUM,COUNT,AVG）を使用した条件指定に使われる。

例

```sql
SELECT department, COUNT(employee_id)
FROM employees
WHERE hire_date >= '2020-01-01'  -- データを絞る（WHERE句）
GROUP BY department
HAVING COUNT(employee_id) > 10  -- 集計結果に対する条件（HAVING句）
```

GROUP BY で部門（department）ごとに集計をしている。部門ごとの集計結果に対して、社員（employee_id）が 10 人を超える部門という条件を適用している。

## WITH

WITH は、一時的にサブクエリに名前をつけて管理することができる機能。共通テーブル式(CTE：Common Table Expression)という。  
テーブル結合するクエリや複雑なサブクエリを記述する際に、WITH 句を使うことで可読性が向上する。

■ 構文

```sql
WITH [一時テーブル名](列名, ...) AS (サブクエリ)
```

■ 例

```sql
WITH tmp_users AS (SELECT id, name FROM users)
SELECT \* FROM tmp_users;
```

WITH で定義した一時テーブルは、通常のテーブルのように使うことができる。

## WITH RECURSIVE

再帰的な共通テーブル式(再帰 CTE)。  
階層構造（親子関係を持つデータ）や再帰的な関係を持つデータを効率的に取得することができる。

[R6 秋 トレーディングカードの個人売買サイトの構築](https://www.ap-siken.com/kakomon/06_aki/pm06.html) で出た。

■ 構文

```sql
WITH RECURSIVE [再帰テーブル名](列名, ...)  AS (
  -- 基底部：再起処理の初期状態（終了条件のないクエリ）
  初期クエリ
  UNION ALL
  -- 再帰部：前回の結果をもとに繰り返し処理を行うクエリ
  再帰クエリ（再起テーブル名を参照する）
)
```

- 基底部：再起処理の開始点。初期のクエリ結果を返す。
- 再帰部：再帰テーブルを参照し、新しい結果を生成する。これが終了条件に達するまで繰り返される。
- UNION ALL：基底部と再帰部

■UNION と UNION ALL の違い

- UNION：重複行は除外
- UNION ALL：重複行もそのまま保持

■WITH RECURSIVE で UNION ALL が推奨される理由  
UNION は重複チェックを行うため、再起的な処理ではパフォーマンス面で UNION ALL に劣る。  
また、再帰クエリの中間結果で重複が発生することがあるため、UNION ALL の方が推奨される。

## BETWEEN

BETWEEN 句は、指定した範囲内の値を取得するための条件式に使用される。  
数値だけでなく、日付型や文字列型のデータにも対応する。

[R6 春 クラウドサービスを活用した情報提供システムの構築](https://www.ap-siken.com/kakomon/06_haru/pm06.html) で出た。

■ 構文

```sql
列名 BETWEEN 下限値 AND 上限値
列名 NOT BETWEEN 下限値 AND 上限値
```

なお、下限値と上限値の値も条件に含まれるため以下と同じ意味。

```sql
列名 >= 下限値 AND 列名 <= 上限値
```

■ 注意点  
・範囲の順序は指定通り（小さい値から先に書く）こと  
・NULL の扱い（NULL が含まれている場合、BETWEEN 句ではその行は除外される）  
・日付型を扱う場合は、データベースのフォーマットに従った正しい形式で指定すること

# その他

## VIEW

VIEW は、データベース内の仮想的なテーブル。  
物理的なデータを格納するわけではなく、「クエリの結果をもとに動的に生成されるテーブル」として機能する。

似たもので WITH 句があるが、WITH 句は一時的な名前付きのクエリ。  
一方 VIEW は、仮想テーブルでデータベースに永続的に保存される（一時的なものではない）。ちなみに VIEW はデータベースオブジェクト。

■ 構文
・VIEW の作成

```sql
CREATE VIEW [ビュー名] AS
SELECT カラム1, カラム2, ...
FROM テーブル名
WHERE 条件;
```

・VIEW の更新

```sql
CREATE OR REPLACE VIEW [ビュー名] AS
SELECT ...
FROM ...
WHERE ...;
```

・VIEW の削除

```sql
DROP VIEW [ビュー名]
```

■ 特徴と利点

- 再利用性（複雑なクエリを簡略化し再利用できる）
- セキュリティ（必要なカラムや条件だけを公開することで、下のテーブルの詳細を隠すことができる）
- 可読性の向上
- メンテナンス性（複雑なクエリをビューとして定義することで、修正が必要な場合もビューの更新で済む）

■ 注意点

- VIEW は仮想テーブルのため、下のテーブルが変更されると自動的にビューにも反映される
- VIEW は基本読み取り専用。ただし、一部 VIEW はデータの挿入や更新が可能（下のテーブルに主キーがある、JOIN や GROUP BY が含まれない、VIEW の全ての列が 1 対 1 で下のテーブルと対応している）
