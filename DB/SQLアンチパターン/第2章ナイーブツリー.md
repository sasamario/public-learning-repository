# 第2章ナイーブツリー（素朴な木） p13〜31
結論： TODO:全て読み終わったら記載

また以下サイトが図の説明もあり、とてもわかりやすかった！！
- [MySQLで階層構造を扱うための再帰的なクエリの実装方法と実用例](https://zenn.dev/rescuenow/articles/c7d7291f2deed8)

## アンチパターン発生の背景
階層型のデータ（例：スレッド形式の掲示板）で、親にのみ依存する構造としている  
※ただし、階層の深さであったり使用するDBによっては上記構造でも問題ない場合もある


## アンチパターンによる影響
以下の場合に難しくなったり、複雑化する
- 子孫データなど遠い関係を持つデータの取得
- データのメンテナンス（削除）
	- →ノードを削除すると子孫ノードから順に削除する必要が出てくる（整合性制約）

## 解決策
代替ツリーモデルの使用。  
代替ツリーモデルには以下の3つがある。

- 経路列挙モデル
- 入れ子集合モデル
- 閉包テーブルモデル

それぞれの手法のメリット・デメリットを以下にまとめる（参考：SQLアンチパターンp30）。

| 設計手法 | テーブル数 | 子へのクエリ実行 | ツリーへのクエリ実行 | 挿入 | 削除 | 参照整合性維持 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 隣接リスト | 1 | 簡単 | 難しい | 簡単 | 簡単 | 可能 |
| ○再帰クエリ | 1 | 簡単 | 簡単 | 簡単 | 簡単 | 可能 |
| 経路列挙 | 1 | 簡単 | 簡単 | 簡単 | 簡単 | 不可 |
| 入れ子集合 | 1 | 難しい | 難しい | 難しい | 難しい | 不可 |
| 閉包テーブル | 2 | 簡単 | 簡単 | 簡単 | 簡単 | 簡単 |

隣接リスト：一般的な設計。構造がシンプルなため、階層が深くなく制限がある場合や再帰クエリが使える場合はあり。



### 経路列挙モデル
親データから自身までのパス（経路）を情報として持つ方法。  
イメージとしてはファイルシステム /var/www/html みたいな

| ID | パス | コメント |
| ---- | ---- | ---- |
| 1 | 1/ | コメント1 |
| 2 | 1/2/ | コメント1に対するリプライ1 |
| 3 | 1/3/ | コメント1に対するリプライ2 |
| 4 | 1/2/4/ | コメント2に対するリプライ |

■メリット  
- 追加は、追加したい親のパス+自身のIDをつければできる
- 検索は、パターンマッチを行うことで容易

■デメリット  
- 経路を文字列として持つため、第一章で触れたジェイウォークのような欠点がある
	- インデックスが効かない
	- 外部キー設定ができない
	- パス文字列のメンテナンスはアプリケーション側に依存する（値のチェック等）
	- 文字列長さの制限の影響を受ける場合あり
- 更新や削除が難しい（更新すると他のパスも更新が必要になる）


### 入れ子集合モデル（イメージが難しい...）
入れ子集合は直近の親ではなく、「子孫の集合」に関する情報を各ノードに格納する。  
各データの左(nsleft)と右(nsright)にノードに関する値を持つ（正直文章を見てもパッとしないので、以下サイトの図解をみるとよい）  
[入れ子集合のデータの持ち方](https://zenn.dev/rescuenow/articles/c7d7291f2deed8#%E5%85%A5%E3%82%8C%E5%AD%90%E9%9B%86%E5%90%88%E3%81%AE%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AE%E6%8C%81%E3%81%A1%E6%96%B9)

nsleft：そのノードより下の階層にあるすべてのノードが持つ値より小さな値  
nsright：そのノードより下の階層にある全てのノードが持つ値より大きな値  

■メリット  
- 検索が容易
	- 対象データの子孫ノードを取得したい場合は、nsleftとnsrightの間に含むノードを全て取得すればいい
	- →between nsleft and nsright みたいな感じで
- 削除が容易
	- 中間ノードを削除した時、削除したノードの子孫ノードは削除したノードの親の直接的な子と自動的になる点

■デメリット  
- 直近の親の取得などが隣接リストより難しくなる
- 追加や更新が難しくなる
	- 関連するノードの左右値の再計算が必要になる

入れ子集合モデルが適しているのは、個々のノードの操作ではなく、サブツリーに対する迅かつ容易なクエリ実行が重要な場合。  
ノードの挿入などが頻繁に発生する場合は適していない。



### 参考サイト
- [ツリー構造のデータをRDBで扱う](https://qiita.com/tosh_m/items/d11c47e81508b92426fb)



## 不明点調査
### 隣接リスト
各ノードが親ノードへの参照を持つ手法。

以下ChatGPTに出力してもらったテーブルとデータサンプル。  

```sql
CREATE TABLE Employee (
    EmployeeID INT PRIMARY KEY,
    Name VARCHAR(50),
    ManagerID INT, -- 親ノードへの参照
    FOREIGN KEY (ManagerID) REFERENCES Employee(EmployeeID)
);

-- データの例
INSERT INTO Employee (EmployeeID, Name, ManagerID) VALUES
(1, 'CEO', NULL), -- 最上位のノード
(2, 'Manager A', 1), -- CEOの直下のノード
(3, 'Manager B', 1), -- CEOの直下のノード
(4, 'Employee X', 2), -- Manager Aの直下のノード
(5, 'Employee Y', 2), -- Manager Aの直下のノード
(6, 'Employee Z', 3); -- Manager Bの直下のノード

```
Employeeテーブル  
従業員テーブル。各レコードが従業員データ。ManagerIdが親ノード（上司）への参照を表している。  
最上位の役職は上司がいない（根ノード：最上位ノード）ため、NULLとなっている。  

■メリット  
構造がシンプルで隣接した親子関係のデータ取得が容易。  

■デメリット  
フォルダの階層が深い場合は、その階層分結合が必要になる（階層が浅い場合や深さを制限する場合は、シンプルな構造なので良い）。  
ただし、再帰クエリをサポートしているDBではこのデメリットは解消できる。  
また、削除時に物理削除だと整合性を保つコストが結構かかるため論理削除でデータ上は階層構造を保つということも手ではある。

■参考  
- [隣接リスト（ナイーブツリー）のデータの持ち方](https://zenn.dev/rescuenow/articles/c7d7291f2deed8#%E9%9A%A3%E6%8E%A5%E3%83%AA%E3%82%B9%E3%83%88%EF%BC%88%E3%83%8A%E3%82%A4%E3%83%BC%E3%83%96%E3%83%84%E3%83%AA%E3%83%BC%EF%BC%89%E3%81%AE%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AE%E6%8C%81%E3%81%A1%E6%96%B9)


### 再帰クエリ
クエリの結果に対して同じクエリを繰り返し実行するもの。  
DBによっては対応していない場合がある。

#### with句について
with句は一時的にサブクエリに名前をつけて管理することができるもの。  
一時テーブルのようなもの。以下WITH句の使用例。

```sql
WITH cte_name (column1, column2, ...) AS (
    -- CTE(Common Table Expressions)の定義部分
    SELECT column1, column2, ...
    FROM some_table
    WHERE some_condition
)
-- 以降のクエリ部分で cte_name を使用できる
SELECT *
FROM cte_name;
```

後述する再帰クエリで「WITH RECURSIVE」が使われる。  
これで再帰クエリを定義して、再帰的な自己参照的なクエリを可能にする。

#### WITH RECURSIVE
WITH RECURSIVEを使うことで、再帰クエリを定義することができる。

以下ChatGPTによるサンプルクエリ
```sql
-- 再帰クエリ用のサンプルテーブル
CREATE TABLE Employee (
    EmployeeID INT PRIMARY KEY,
    Name VARCHAR(50),
    ManagerID INT, -- 上司への参照
    FOREIGN KEY (ManagerID) REFERENCES Employee(EmployeeID)
);

INSERT INTO Employee (EmployeeID, Name, ManagerID) VALUES
(1, 'CEO', NULL),
(2, 'Manager A', 1),
(3, 'Manager B', 1),
(4, 'Employee X', 2),
(5, 'Employee Y', 2),
(6, 'Employee Z', 3),
(7, 'Employee P', 4),
(8, 'Employee Q', 4);
```

```sql
-- 再帰クエリサンプル
WITH RECURSIVE OrgChart AS (
    SELECT EmployeeID, Name, ManagerID
    FROM Employee
    WHERE ManagerID IS NULL  -- ルートノード（CEO）からスタート
    UNION
    SELECT e.EmployeeID, e.Name, e.ManagerID
    FROM Employee e
    JOIN OrgChart o ON e.ManagerID = o.EmployeeID
)
SELECT * FROM OrgChart;
```

WITH RECURSIVEは、大きく分けて以下の2構成となっている。  
- UNION(UNION ALL)より上にある「非再帰項」
- UNION(UNION ALL)より下にある「再帰項」

このSQLクエリでは、WITH RECURSIVE 句を使用して OrgChart という一時的なテーブルを作成している。  
非再帰項のクエリで、ルートノードのレコードを取得。  
次にUNIONを使用して、再帰的に従業員とその上司の情報を結合している。  
この例では一時テーブルであるOrgChartテーブルが再帰的に自信を参照することで、組織図を階層的に取得している。


■参考
- [再帰SQL -図解-](https://qiita.com/Shoyu_N/items/f1786f99545fa5053b75)
- [SQLにおけるWITH句の基本的な使い方とUPDATE文での活用方法](https://techplay.jp/column/1702)